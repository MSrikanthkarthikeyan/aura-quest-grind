export interface AIQuestRequest {
  roles: string[];
  goals: string[];
  skillLevel: 'Beginner' | 'Intermediate' | 'Advanced';
  timeCommitment: string;
  fitnessTypes?: string[];
}

export interface AIQuestResponse {
  title: string;
  duration: string;
  subtasks: string[];
  difficulty: 'Easy' | 'Moderate' | 'Hard';
  frequency: 'Daily' | 'Weekly' | 'Once' | 'Custom';
  category: string;
  xpReward: number;
}

interface OnboardingResponse {
  message: string;
  extractedData?: Partial<UserProfile>;
  isComplete: boolean;
  finalProfile?: UserProfile;
}

interface UserProfile {
  interests: string[];
  goals: string;
  routine: string;
  questStyle: string;
  timeCommitment: string;
  fitnessPreferences?: string[];
  skillLevel: string;
}

interface ProfileAnswers {
  mainGoal?: string;
  focusAreas?: string[];
  dailyHours?: number;
  questStyle?: string;
  notes?: string;
}

const GEMINI_API_KEY = 'AIzaSyCh_5H3df-gsWXiQWbD7aG5br6FD0jE1sI';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

export const generateAIQuests = async (request: AIQuestRequest): Promise<AIQuestResponse[]> => {
  console.log('Gemini API: Starting quest generation with request:', request);
  const prompt = createQuestPrompt(request);
  console.log('Gemini API: Generated prompt:', prompt);
  
  try {
    console.log('Gemini API: Making request to:', `${GEMINI_API_URL}?key=${GEMINI_API_KEY.substring(0, 10)}...`);
    
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 2048,
        }
      })
    });

    console.log('Gemini API: Response status:', response.status);
    console.log('Gemini API: Response ok:', response.ok);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API: Error response body:', errorText);
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('Gemini API: Full response data:', data);
    
    const generatedText = data.candidates[0]?.content?.parts[0]?.text;
    console.log('Gemini API: Generated text:', generatedText);
    
    if (!generatedText) {
      console.error('Gemini API: No content generated');
      throw new Error('No content generated by Gemini AI');
    }

    const parsedQuests = parseAIResponse(generatedText);
    console.log('Gemini API: Parsed quests:', parsedQuests);
    
    return parsedQuests;
  } catch (error) {
    console.error('Gemini API: Error generating AI quests:', error);
    throw error;
  }
};

export const generateProfileSummary = async (answers: ProfileAnswers): Promise<string> => {
  console.log('Generating profile summary for:', answers);
  
  const prompt = `Based on the following user onboarding responses, generate a brief, encouraging 1-2 sentence summary of their personalized quest profile:

Main Goal: ${answers.mainGoal}
Focus Areas: ${answers.focusAreas?.join(', ')}
Daily Hours: ${answers.dailyHours}
Quest Style: ${answers.questStyle}
Additional Notes: ${answers.notes}

Write a friendly, RPG-themed summary that acknowledges their goals and shows you understand their preferences. Keep it under 150 characters and use gaming terminology like "hunter", "quests", "level up", etc.`;

  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.8,
          maxOutputTokens: 200,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    const summary = data.candidates[0]?.content?.parts[0]?.text;
    
    return summary || `Perfect! You're all set to ${answers.questStyle?.toLowerCase()} and level up in ${answers.focusAreas?.join(' and ')}.`;
    
  } catch (error) {
    console.error('Error generating profile summary:', error);
    return `Your quest profile is ready! Time to start grinding and level up in ${answers.focusAreas?.join(' and ') || 'your chosen areas'}.`;
  }
};

export const generateOnboardingResponse = async (
  conversationHistory: string,
  userInputCount: number,
  currentData: Partial<ProfileAnswers>,
  isFinalAnalysis: boolean = false
): Promise<OnboardingResponse> => {
  console.log('Onboarding AI: Starting conversation generation');
  console.log('User inputs so far:', userInputCount);
  console.log('Current data:', currentData);
  console.log('Is final analysis:', isFinalAnalysis);

  const prompt = createDynamicOnboardingPrompt(conversationHistory, userInputCount, currentData, isFinalAnalysis);
  
  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.8,
          maxOutputTokens: 1024,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    const generatedText = data.candidates[0]?.content?.parts[0]?.text;
    
    if (!generatedText) {
      throw new Error('No response generated');
    }

    return parseOnboardingResponse(generatedText, userInputCount, currentData, isFinalAnalysis);
    
  } catch (error) {
    console.error('Onboarding AI Error:', error);
    return getFallbackResponse(userInputCount, currentData, isFinalAnalysis);
  }
};

const createQuestPrompt = (request: AIQuestRequest): string => {
  const rolesText = request.roles.join(', ');
  const goalsText = request.goals.join(', ');
  const fitnessText = request.fitnessTypes ? `, with fitness focus on ${request.fitnessTypes.join(', ')}` : '';

  return `Generate 3-5 personalized quests for a user who is a ${rolesText} aiming to ${goalsText}. The user is a ${request.skillLevel} level and has ${request.timeCommitment} available${fitnessText}.

Please provide your response in the following JSON format:
[
  {
    "title": "Quest title (gamified, RPG-themed like 'Shadow Script Practice' or 'Algorithm Abyss')",
    "duration": "Realistic time estimate (e.g., '30 minutes', '2 hours')",
    "subtasks": ["actionable step 1", "actionable step 2", "actionable step 3"],
    "difficulty": "Easy|Moderate|Hard",
    "frequency": "Daily|Weekly|Once|Custom",
    "category": "Tech|Academics|Business|Content|Fitness|Personal",
    "xpReward": 25-100
  }
]

Requirements:
- Use engaging, RPG-themed quest titles
- Keep subtasks actionable and motivational
- Match difficulty to user's skill level
- Ensure time estimates are realistic
- Categories should match: Tech, Academics, Business, Content, Fitness, Personal
- XP rewards: Easy (25-40), Moderate (45-70), Hard (75-100)

Return only the JSON array, no additional text.`;
};

const createDynamicOnboardingPrompt = (
  conversationHistory: string,
  userInputCount: number,
  currentData: Partial<ProfileAnswers>,
  isFinalAnalysis: boolean
): string => {
  const maxInputs = 5;
  const remainingInputs = maxInputs - userInputCount;

  if (isFinalAnalysis) {
    return `You are completing the onboarding for AuraQuestGrind. Based on the conversation history, create a final summary and complete user profile.

CONVERSATION HISTORY:
${conversationHistory}

CURRENT DATA COLLECTED:
${JSON.stringify(currentData)}

Create a final response with:
1. A celebratory message acknowledging their goals
2. A complete user profile extraction

RESPONSE FORMAT:
{
  "message": "Encouraging completion message with summary of their goals (keep under 150 words)",
  "extractedData": {
    "mainGoal": "main objective",
    "focusAreas": ["area1", "area2"],
    "dailyCommitment": "time commitment",
    "questStyle": "preferred style",
    "personalNote": "additional context",
    "skillLevel": "beginner/intermediate/advanced"
  },
  "isComplete": true,
  "finalProfile": {
    "interests": ["converted focus areas"],
    "goals": "main goal summary",
    "routine": "routine description",
    "questStyle": "quest style preference",
    "timeCommitment": "time commitment",
    "fitnessPreferences": ["fitness related areas if any"],
    "skillLevel": "skill level"
  }
}

Return only valid JSON.`;
  }

  return `You are an AI mentor for AuraQuestGrind, a gamified productivity app. You're having a natural conversation with a new user to understand their goals and preferences.

CONVERSATION SO FAR:
${conversationHistory}

CONTEXT:
- This is input #${userInputCount} out of ${maxInputs} maximum
- Remaining inputs: ${remainingInputs}
- Current data: ${JSON.stringify(currentData)}

YOUR TASK:
- Ask ONE natural, conversational question that helps understand their goals, interests, or preferences
- Be friendly, encouraging, and use gaming terminology
- Keep responses under 80 words
- ${remainingInputs <= 2 ? 'Focus on missing key information since you\'re running out of inputs' : 'Continue natural conversation flow'}

INFORMATION TO GATHER:
- Main goals (career, fitness, academics, personal growth)
- Focus areas/interests  
- Daily time commitment
- Preferred style (structured vs flexible)
- Skill level
- Personal context/motivation

RESPONSE FORMAT:
{
  "message": "Your conversational response with next question",
  "extractedData": {
    "mainGoal": "extracted goal if mentioned",
    "focusAreas": ["extracted interests"],
    "dailyCommitment": "time mentioned if any", 
    "questStyle": "style preference if mentioned",
    "personalNote": "additional context",
    "skillLevel": "skill level if mentioned"
  },
  "isComplete": false
}

Return only valid JSON.`;
};

const parseOnboardingResponse = (
  response: string,
  userInputCount: number,
  currentData: Partial<ProfileAnswers>,
  isFinalAnalysis: boolean = false
): OnboardingResponse => {
  try {
    // Extract JSON from response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    
    // Merge extracted data with current data
    const mergedData = { ...currentData, ...parsed.extractedData };
    
    return {
      message: parsed.message || 'Tell me more about your goals!',
      extractedData: parsed.extractedData || {},
      isComplete: parsed.isComplete || isFinalAnalysis,
      finalProfile: parsed.finalProfile || (isFinalAnalysis ? createCompleteProfile(mergedData) : undefined)
    };
    
  } catch (error) {
    console.error('Error parsing onboarding response:', error);
    return getFallbackResponse(userInputCount, currentData, isFinalAnalysis);
  }
};

const createCompleteProfile = (data: Partial<ProfileAnswers>): UserProfile => {
  return {
    interests: data.focusAreas || ['Personal Development'],
    goals: data.mainGoal || 'Improve productivity and build better habits',
    routine: data.dailyCommitment || 'Flexible schedule',
    questStyle: data.questStyle || 'Gamified',
    timeCommitment: data.dailyCommitment || '1-2 hours daily',
    fitnessPreferences: data.focusAreas?.filter(area => 
      area.toLowerCase().includes('fitness') || 
      area.toLowerCase().includes('health') ||
      area.toLowerCase().includes('workout')
    ) || [],
    skillLevel: data.skillLevel || 'Intermediate'
  };
};

const getFallbackResponse = (
  userInputCount: number,
  currentData: Partial<ProfileAnswers>,
  isFinalAnalysis: boolean = false
): OnboardingResponse => {
  if (isFinalAnalysis) {
    return {
      message: "ðŸŽ‰ Perfect! I've got everything I need to create your personalized quest profile. Your adventure is about to begin!",
      extractedData: {},
      isComplete: true,
      finalProfile: createCompleteProfile(currentData)
    };
  }

  const fallbackQuestions = [
    "ðŸŽ¯ What's your main goal right now? (e.g., get fit, learn coding, build habits)",
    "ðŸ’ª Which areas interest you most? (tech, fitness, academics, business, etc.)",
    "â° How much time can you dedicate daily to your quests?",
    "âš”ï¸ Do you prefer structured schedules or flexible challenges?",
    "ðŸš€ What's your experience level in your main areas of focus?"
  ];

  const question = fallbackQuestions[Math.min(userInputCount - 1, fallbackQuestions.length - 1)];
  
  return {
    message: question,
    extractedData: {},
    isComplete: userInputCount >= 5,
    finalProfile: userInputCount >= 5 ? createCompleteProfile(currentData) : undefined
  };
};

const parseAIResponse = (response: string): AIQuestResponse[] => {
  console.log('Parsing AI response:', response);
  
  try {
    // Clean the response to extract JSON
    const jsonMatch = response.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      console.error('No JSON array found in response');
      throw new Error('No JSON array found in response');
    }
    
    const cleanedResponse = jsonMatch[0];
    console.log('Extracted JSON:', cleanedResponse);
    
    const quests = JSON.parse(cleanedResponse);
    console.log('Parsed JSON quests:', quests);
    
    const mappedQuests = quests.map((quest: any) => ({
      title: quest.title || 'Generated Quest',
      duration: quest.duration || '30 minutes',
      subtasks: Array.isArray(quest.subtasks) ? quest.subtasks : [],
      difficulty: quest.difficulty || 'Moderate',
      frequency: quest.frequency || 'Daily',
      category: quest.category || 'Personal',
      xpReward: quest.xpReward || 35,
    }));
    
    console.log('Final mapped quests:', mappedQuests);
    return mappedQuests;
  } catch (error) {
    console.error('Error parsing AI response:', error);
    // Return fallback quest if parsing fails
    const fallbackQuests = [{
      title: 'Custom AI Quest',
      duration: '30 minutes',
      subtasks: ['Complete your daily challenge', 'Track your progress'],
      difficulty: 'Moderate' as const,
      frequency: 'Daily' as const,
      category: 'Personal',
      xpReward: 35,
    }];
    
    console.log('Returning fallback quests:', fallbackQuests);
    return fallbackQuests;
  }
};
