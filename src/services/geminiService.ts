export interface AIQuestRequest {
  roles: string[];
  goals: string[];
  skillLevel: 'Beginner' | 'Intermediate' | 'Advanced';
  timeCommitment: string;
  fitnessTypes?: string[];
}

export interface AIQuestResponse {
  title: string;
  duration: string;
  subtasks: string[];
  difficulty: 'Easy' | 'Moderate' | 'Hard';
  frequency: 'Daily' | 'Weekly' | 'Once' | 'Custom';
  category: string;
  xpReward: number;
}

interface OnboardingResponse {
  message: string;
  extractedData?: Partial<UserProfile>;
  isComplete: boolean;
  finalProfile?: UserProfile;
}

interface UserProfile {
  interests: string[];
  goals: string;
  routine: string;
  questStyle: string;
  timeCommitment: string;
  fitnessPreferences?: string[];
  skillLevel: string;
}

interface ProfileAnswers {
  mainGoal?: string;
  focusAreas?: string[];
  dailyHours?: number;
  questStyle?: string;
  notes?: string;
}

const GEMINI_API_KEY = 'AIzaSyCh_5H3df-gsWXiQWbD7aG5br6FD0jE1sI';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

export const generateAIQuests = async (request: AIQuestRequest): Promise<AIQuestResponse[]> => {
  console.log('Gemini API: Starting quest generation with request:', request);
  const prompt = createQuestPrompt(request);
  console.log('Gemini API: Generated prompt:', prompt);
  
  try {
    console.log('Gemini API: Making request to:', `${GEMINI_API_URL}?key=${GEMINI_API_KEY.substring(0, 10)}...`);
    
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 2048,
        }
      })
    });

    console.log('Gemini API: Response status:', response.status);
    console.log('Gemini API: Response ok:', response.ok);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API: Error response body:', errorText);
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('Gemini API: Full response data:', data);
    
    const generatedText = data.candidates[0]?.content?.parts[0]?.text;
    console.log('Gemini API: Generated text:', generatedText);
    
    if (!generatedText) {
      console.error('Gemini API: No content generated');
      throw new Error('No content generated by Gemini AI');
    }

    const parsedQuests = parseAIResponse(generatedText);
    console.log('Gemini API: Parsed quests:', parsedQuests);
    
    return parsedQuests;
  } catch (error) {
    console.error('Gemini API: Error generating AI quests:', error);
    throw error;
  }
};

export const generateProfileSummary = async (answers: ProfileAnswers): Promise<string> => {
  console.log('Generating profile summary for:', answers);
  
  const prompt = `Based on the following user onboarding responses, generate a brief, encouraging 1-2 sentence summary of their personalized quest profile:

Main Goal: ${answers.mainGoal}
Focus Areas: ${answers.focusAreas?.join(', ')}
Daily Hours: ${answers.dailyHours}
Quest Style: ${answers.questStyle}
Additional Notes: ${answers.notes}

Write a friendly, RPG-themed summary that acknowledges their goals and shows you understand their preferences. Keep it under 150 characters and use gaming terminology like "hunter", "quests", "level up", etc.`;

  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.8,
          maxOutputTokens: 200,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    const summary = data.candidates[0]?.content?.parts[0]?.text;
    
    return summary || `Perfect! You're all set to ${answers.questStyle?.toLowerCase()} and level up in ${answers.focusAreas?.join(' and ')}.`;
    
  } catch (error) {
    console.error('Error generating profile summary:', error);
    return `Your quest profile is ready! Time to start grinding and level up in ${answers.focusAreas?.join(' and ') || 'your chosen areas'}.`;
  }
};

export const generateOnboardingResponse = async (
  conversationHistory: string,
  questionsAsked: number,
  currentData: Partial<UserProfile>
): Promise<OnboardingResponse> => {
  console.log('Onboarding AI: Starting conversation generation');
  console.log('Questions asked so far:', questionsAsked);
  console.log('Current data:', currentData);

  const prompt = createOnboardingPrompt(conversationHistory, questionsAsked, currentData);
  
  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.8,
          maxOutputTokens: 1024,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    const generatedText = data.candidates[0]?.content?.parts[0]?.text;
    
    if (!generatedText) {
      throw new Error('No response generated');
    }

    return parseOnboardingResponse(generatedText, questionsAsked, currentData);
    
  } catch (error) {
    console.error('Onboarding AI Error:', error);
    return getFallbackResponse(questionsAsked, currentData);
  }
};

const createQuestPrompt = (request: AIQuestRequest): string => {
  const rolesText = request.roles.join(', ');
  const goalsText = request.goals.join(', ');
  const fitnessText = request.fitnessTypes ? `, with fitness focus on ${request.fitnessTypes.join(', ')}` : '';

  return `Generate 3-5 personalized quests for a user who is a ${rolesText} aiming to ${goalsText}. The user is a ${request.skillLevel} level and has ${request.timeCommitment} available${fitnessText}.

Please provide your response in the following JSON format:
[
  {
    "title": "Quest title (gamified, RPG-themed like 'Shadow Script Practice' or 'Algorithm Abyss')",
    "duration": "Realistic time estimate (e.g., '30 minutes', '2 hours')",
    "subtasks": ["actionable step 1", "actionable step 2", "actionable step 3"],
    "difficulty": "Easy|Moderate|Hard",
    "frequency": "Daily|Weekly|Once|Custom",
    "category": "Tech|Academics|Business|Content|Fitness|Personal",
    "xpReward": 25-100
  }
]

Requirements:
- Use engaging, RPG-themed quest titles
- Keep subtasks actionable and motivational
- Match difficulty to user's skill level
- Ensure time estimates are realistic
- Categories should match: Tech, Academics, Business, Content, Fitness, Personal
- XP rewards: Easy (25-40), Moderate (45-70), Hard (75-100)

Return only the JSON array, no additional text.`;
};

const createOnboardingPrompt = (
  conversationHistory: string,
  questionsAsked: number,
  currentData: Partial<UserProfile>
): string => {
  const maxQuestions = 5;
  const isNearEnd = questionsAsked >= maxQuestions - 2;

  return `You are an AI companion for AuraQuestGrind, a gamified habit tracker and productivity app. You're having a friendly onboarding conversation with a new user.

CONTEXT:
- This is question #${questionsAsked + 1} in the onboarding flow
- Maximum questions: ${maxQuestions}
- Current user data collected: ${JSON.stringify(currentData)}

CONVERSATION HISTORY:
${conversationHistory}

YOUR ROLE:
- Be friendly, encouraging, and gaming-themed (think RPG/anime vibes)
- Ask ONE focused question per response
- Keep responses under 100 words
- Use emojis and gaming terminology (quests, level up, grinding, etc.)

INFORMATION TO GATHER:
1. Main interests/focus areas (tech, fitness, academics, business, personal)
2. Specific goals they want to achieve
3. Available time commitment (daily hours/routine)
4. Preferred learning/work style (structured vs flexible)
5. Skill level (beginner, intermediate, advanced)

RESPONSE FORMAT:
{
  "message": "Your conversational response with next question",
  "extractedData": {
    "interests": ["array", "of", "interests"],
    "goals": "summarized goals",
    "timeCommitment": "time info",
    "routine": "routine preferences",
    "questStyle": "style preferences",
    "skillLevel": "skill level"
  },
  "isComplete": ${isNearEnd ? 'true if you have enough info' : 'false'},
  "finalProfile": ${isNearEnd ? 'complete profile object if ready' : 'null'}
}

${isNearEnd ? 'If you have enough information, set isComplete to true and provide a complete finalProfile object.' : 'Continue gathering information naturally.'}

Return only valid JSON.`;
};

const parseOnboardingResponse = (
  response: string,
  questionsAsked: number,
  currentData: Partial<UserProfile>
): OnboardingResponse => {
  try {
    // Extract JSON from response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    
    // Merge extracted data with current data
    const mergedData = { ...currentData, ...parsed.extractedData };
    
    return {
      message: parsed.message || 'Let me know more about your goals!',
      extractedData: parsed.extractedData,
      isComplete: parsed.isComplete || false,
      finalProfile: parsed.isComplete ? createCompleteProfile(mergedData) : undefined
    };
    
  } catch (error) {
    console.error('Error parsing onboarding response:', error);
    return getFallbackResponse(questionsAsked, currentData);
  }
};

const createCompleteProfile = (data: Partial<UserProfile>): UserProfile => {
  return {
    interests: data.interests || ['Personal Development'],
    goals: data.goals || 'Improve productivity and build better habits',
    routine: data.routine || 'Flexible schedule',
    questStyle: data.questStyle || 'Gamified',
    timeCommitment: data.timeCommitment || '1-2 hours daily',
    fitnessPreferences: data.fitnessPreferences || [],
    skillLevel: data.skillLevel || 'Intermediate'
  };
};

const getFallbackResponse = (
  questionsAsked: number,
  currentData: Partial<UserProfile>
): OnboardingResponse => {
  const fallbackQuestions = [
    "What areas would you like to focus on? (tech, fitness, academics, etc.)",
    "What are your main goals for self-improvement?",
    "How much time can you dedicate daily to your quests?",
    "Do you prefer structured routines or flexible challenges?",
    "What's your current skill level in your main areas of interest?"
  ];

  const question = fallbackQuestions[Math.min(questionsAsked, fallbackQuestions.length - 1)];
  
  return {
    message: `🎮 ${question}`,
    extractedData: {},
    isComplete: questionsAsked >= 4,
    finalProfile: questionsAsked >= 4 ? createCompleteProfile(currentData) : undefined
  };
};

const parseAIResponse = (response: string): AIQuestResponse[] => {
  console.log('Parsing AI response:', response);
  
  try {
    // Clean the response to extract JSON
    const jsonMatch = response.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      console.error('No JSON array found in response');
      throw new Error('No JSON array found in response');
    }
    
    const cleanedResponse = jsonMatch[0];
    console.log('Extracted JSON:', cleanedResponse);
    
    const quests = JSON.parse(cleanedResponse);
    console.log('Parsed JSON quests:', quests);
    
    const mappedQuests = quests.map((quest: any) => ({
      title: quest.title || 'Generated Quest',
      duration: quest.duration || '30 minutes',
      subtasks: Array.isArray(quest.subtasks) ? quest.subtasks : [],
      difficulty: quest.difficulty || 'Moderate',
      frequency: quest.frequency || 'Daily',
      category: quest.category || 'Personal',
      xpReward: quest.xpReward || 35,
    }));
    
    console.log('Final mapped quests:', mappedQuests);
    return mappedQuests;
  } catch (error) {
    console.error('Error parsing AI response:', error);
    // Return fallback quest if parsing fails
    const fallbackQuests = [{
      title: 'Custom AI Quest',
      duration: '30 minutes',
      subtasks: ['Complete your daily challenge', 'Track your progress'],
      difficulty: 'Moderate' as const,
      frequency: 'Daily' as const,
      category: 'Personal',
      xpReward: 35,
    }];
    
    console.log('Returning fallback quests:', fallbackQuests);
    return fallbackQuests;
  }
};
